# 调试电机

##### 在进行电机调试的时候，需先对can条进行初始化

```
sudo ip link set can0 up type can bitrate 1000000
```

##### 然后需要创建yaml文件

内容如下

```
rm_hw:
  bus:
    - can0
  loop_frequency: 1000
  cycle_time_error_threshold: 0.001
  thread_priority: 95

  actuators:
    link2_motor:
      bus: can0
      id: 0x201
      type: rm_2006
      lp_cutoff_frequency: 60
```

- 以上代码内容：
- rm_ws表示对某硬件系统的配置
- can0为指定的can总线设备
- loop_frequency为控制系统的循环频率，单位hz
- cycle_time_error_threshold为控制周期最大允许误差
- thread_priority表示优先级，数值越大优先级越大
- actuators为执行器的配置
- link2_motor为想要的电机（urdf中）
- bus: can0 表示使用can0进行通信
- id：0x201 是电机在can上面的id（看电条上面的灯光闪烁次数）
- type：后面写电机的具体型号
- lp_cutoff_frequency:60 表示低通滤波器截止频率，单位hz，也就是说将信号里面60hz以上的滤掉，可以让信息平滑

##### 命令转化：

在队内包中有一个actuator_coefficient.yaml文件，可以将力矩，速度等命令转化为电机可以接受的形式，文件内容如下

```
actuator_coefficient:
  rm_3508: # RoboMaster 3508 without reducer
    act2pos: 0.0007669903  # 2PI/8192
    act2vel: 0.1047197551   # 2PI/60
    act2effort: 1.90702994e-5  # 20/16384*0.0156223893
    effort2act: 52437.561519   # 1/act2effort
    max_out: 16384
  rm_6020: # RoboMaster 3508 motor
    act2pos: 0.0007670840  # 2PI/8192
    act2vel: 0.1047197551   # 2PI/60
    act2effort: 5.880969e-5  # special coefficient identify by hands...
    effort2act: 25000   #
    max_out: 30000
  rm_2006: # RoboMaster 2006 motor
    act2pos: 2.13078897e-5  # 2PI/8192*(1/36)
    act2vel: 0.0029088820   # 2PI/60*(1/36)
    act2effort: 0.00018  #10/10000*0.18
    effort2act: 5555.5555555   # 1/act2effort
    max_out: 10000
  cheetah: # MIT cheetah motor
    act2pos: 0.00291447 # 191/65535
    act2vel: 0.0219780219    # 90/4095
    act2effort: 0.008791208  # 36/4095
    pos2act: 343.115183         # 65535/191
    vel2act: 45.5           # 4095/90
    effort2act: 113.75      # 4095/36
    max_out: 0
    act2pos_offset: -95.5
    act2vel_offset: -45.0
    act2effort_offset: -18.0
    kp2act: 8.19            # 4095/500
    kd2act: 819             # 4095/5
```

##### launch

在launch中使用rosparam加载两个yaml文件的内容，并加载rm_hw节点

> 来自他人的建议[!NOTE]
>
> 在调试电机的时候不要打开gazebo仿真

